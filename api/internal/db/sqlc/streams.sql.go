// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: streams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addStream = `-- name: AddStream :one
INSERT INTO streams 
(
  key, 
  user_id, 
  name, 
  has_custom_thumbnail, 
  is_vod
)
VALUES 
(
  $1, 
  $2, 
  $3, 
  $4, 
  $5
)
ON CONFLICT (key) DO NOTHING 
RETURNING 1
`

type AddStreamParams struct {
	Key                string      `db:"key" json:"key"`
	UserID             int32       `db:"user_id" json:"user_id"`
	Name               string      `db:"name" json:"name"`
	HasCustomThumbnail pgtype.Bool `db:"has_custom_thumbnail" json:"has_custom_thumbnail"`
	IsVod              pgtype.Bool `db:"is_vod" json:"is_vod"`
}

// AddStream
//
//	INSERT INTO streams
//	(
//	  key,
//	  user_id,
//	  name,
//	  has_custom_thumbnail,
//	  is_vod
//	)
//	VALUES
//	(
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	)
//	ON CONFLICT (key) DO NOTHING
//	RETURNING 1
func (q *Queries) AddStream(ctx context.Context, arg AddStreamParams) (int32, error) {
	row := q.db.QueryRow(ctx, addStream,
		arg.Key,
		arg.UserID,
		arg.Name,
		arg.HasCustomThumbnail,
		arg.IsVod,
	)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const checkStreamExistsByKey = `-- name: CheckStreamExistsByKey :one
SELECT 1 FROM streams 
WHERE key = $1
`

// CheckStreamExistsByKey
//
//	SELECT 1 FROM streams
//	WHERE key = $1
func (q *Queries) CheckStreamExistsByKey(ctx context.Context, key string) (int32, error) {
	row := q.db.QueryRow(ctx, checkStreamExistsByKey, key)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const endStream = `-- name: EndStream :one
UPDATE streams 
SET 
  ended_at = NOW(), 
  is_active = FALSE 
WHERE key = $1
  AND is_active IS DISTINCT FROM FALSE
  AND ended_at IS NULL
RETURNING is_vod
`

// EndStream
//
//	UPDATE streams
//	SET
//	  ended_at = NOW(),
//	  is_active = FALSE
//	WHERE key = $1
//	  AND is_active IS DISTINCT FROM FALSE
//	  AND ended_at IS NULL
//	RETURNING is_vod
func (q *Queries) EndStream(ctx context.Context, key string) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, endStream, key)
	var is_vod pgtype.Bool
	err := row.Scan(&is_vod)
	return is_vod, err
}

const getPublicStreams = `-- name: GetPublicStreams :many
SELECT
  u.name AS streamer_name,
  s.key,
  s.name,
  s.has_custom_thumbnail,
  (s.is_active = TRUE AND s.ended_at IS NULL) AS is_live,
  s.is_vod,
  COUNT(v.id) FILTER ( WHERE v.is_watching = TRUE) AS live_viewers
FROM streams s
JOIN users u ON s.user_id = u.id
LEFT JOIN views v ON v.stream_id = s.id
WHERE (s.is_active = TRUE AND s.ended_at IS NULL) OR (s.is_vod = TRUE AND s.ended_at IS NOT NULL)
GROUP BY s.id, u.name
`

type GetPublicStreamsRow struct {
	StreamerName       string      `db:"streamer_name" json:"streamer_name"`
	Key                string      `db:"key" json:"key"`
	Name               string      `db:"name" json:"name"`
	HasCustomThumbnail pgtype.Bool `db:"has_custom_thumbnail" json:"has_custom_thumbnail"`
	IsLive             pgtype.Bool `db:"is_live" json:"is_live"`
	IsVod              pgtype.Bool `db:"is_vod" json:"is_vod"`
	LiveViewers        int64       `db:"live_viewers" json:"live_viewers"`
}

// GetPublicStreams
//
//	SELECT
//	  u.name AS streamer_name,
//	  s.key,
//	  s.name,
//	  s.has_custom_thumbnail,
//	  (s.is_active = TRUE AND s.ended_at IS NULL) AS is_live,
//	  s.is_vod,
//	  COUNT(v.id) FILTER ( WHERE v.is_watching = TRUE) AS live_viewers
//	FROM streams s
//	JOIN users u ON s.user_id = u.id
//	LEFT JOIN views v ON v.stream_id = s.id
//	WHERE (s.is_active = TRUE AND s.ended_at IS NULL) OR (s.is_vod = TRUE AND s.ended_at IS NOT NULL)
//	GROUP BY s.id, u.name
func (q *Queries) GetPublicStreams(ctx context.Context) ([]GetPublicStreamsRow, error) {
	rows, err := q.db.Query(ctx, getPublicStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicStreamsRow
	for rows.Next() {
		var i GetPublicStreamsRow
		if err := rows.Scan(
			&i.StreamerName,
			&i.Key,
			&i.Name,
			&i.HasCustomThumbnail,
			&i.IsLive,
			&i.IsVod,
			&i.LiveViewers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamRemovalDataByKey = `-- name: GetStreamRemovalDataByKey :one
SELECT id, has_custom_thumbnail, is_active, is_vod 
FROM streams 
WHERE key = $1
LIMIT 1
`

type GetStreamRemovalDataByKeyRow struct {
	ID                 int32       `db:"id" json:"id"`
	HasCustomThumbnail pgtype.Bool `db:"has_custom_thumbnail" json:"has_custom_thumbnail"`
	IsActive           pgtype.Bool `db:"is_active" json:"is_active"`
	IsVod              pgtype.Bool `db:"is_vod" json:"is_vod"`
}

// GetStreamRemovalDataByKey
//
//	SELECT id, has_custom_thumbnail, is_active, is_vod
//	FROM streams
//	WHERE key = $1
//	LIMIT 1
func (q *Queries) GetStreamRemovalDataByKey(ctx context.Context, key string) (GetStreamRemovalDataByKeyRow, error) {
	row := q.db.QueryRow(ctx, getStreamRemovalDataByKey, key)
	var i GetStreamRemovalDataByKeyRow
	err := row.Scan(
		&i.ID,
		&i.HasCustomThumbnail,
		&i.IsActive,
		&i.IsVod,
	)
	return i, err
}

const getStreamStatus = `-- name: GetStreamStatus :one
SELECT 
  is_vod,
  (is_active = TRUE AND ended_at IS NULL) AS is_live
FROM streams 
WHERE key = $1 
LIMIT 1
`

type GetStreamStatusRow struct {
	IsVod  pgtype.Bool `db:"is_vod" json:"is_vod"`
	IsLive pgtype.Bool `db:"is_live" json:"is_live"`
}

// GetStreamStatus
//
//	SELECT
//	  is_vod,
//	  (is_active = TRUE AND ended_at IS NULL) AS is_live
//	FROM streams
//	WHERE key = $1
//	LIMIT 1
func (q *Queries) GetStreamStatus(ctx context.Context, key string) (GetStreamStatusRow, error) {
	row := q.db.QueryRow(ctx, getStreamStatus, key)
	var i GetStreamStatusRow
	err := row.Scan(&i.IsVod, &i.IsLive)
	return i, err
}

const getStreamStopDataByKey = `-- name: GetStreamStopDataByKey :one
SELECT id, is_active, is_vod 
FROM streams 
WHERE key = $1
LIMIT 1
`

type GetStreamStopDataByKeyRow struct {
	ID       int32       `db:"id" json:"id"`
	IsActive pgtype.Bool `db:"is_active" json:"is_active"`
	IsVod    pgtype.Bool `db:"is_vod" json:"is_vod"`
}

// GetStreamStopDataByKey
//
//	SELECT id, is_active, is_vod
//	FROM streams
//	WHERE key = $1
//	LIMIT 1
func (q *Queries) GetStreamStopDataByKey(ctx context.Context, key string) (GetStreamStopDataByKeyRow, error) {
	row := q.db.QueryRow(ctx, getStreamStopDataByKey, key)
	var i GetStreamStopDataByKeyRow
	err := row.Scan(&i.ID, &i.IsActive, &i.IsVod)
	return i, err
}

const getUserStreams = `-- name: GetUserStreams :many
SELECT
  s.name,
  s.key,
  s.is_active,
  s.ended_at,
  s.started_at,
  s.total_views,
  s.is_vod,
  COUNT(v.id) FILTER (WHERE v.is_watching = TRUE) AS live_viewers
FROM streams s
LEFT JOIN views v ON v.stream_id = s.id
WHERE s.user_id = $1
GROUP BY s.id
ORDER BY s.id DESC
`

type GetUserStreamsRow struct {
	Name        string             `db:"name" json:"name"`
	Key         string             `db:"key" json:"key"`
	IsActive    pgtype.Bool        `db:"is_active" json:"is_active"`
	EndedAt     pgtype.Timestamptz `db:"ended_at" json:"ended_at"`
	StartedAt   pgtype.Timestamptz `db:"started_at" json:"started_at"`
	TotalViews  pgtype.Int4        `db:"total_views" json:"total_views"`
	IsVod       pgtype.Bool        `db:"is_vod" json:"is_vod"`
	LiveViewers int64              `db:"live_viewers" json:"live_viewers"`
}

// GetUserStreams
//
//	SELECT
//	  s.name,
//	  s.key,
//	  s.is_active,
//	  s.ended_at,
//	  s.started_at,
//	  s.total_views,
//	  s.is_vod,
//	  COUNT(v.id) FILTER (WHERE v.is_watching = TRUE) AS live_viewers
//	FROM streams s
//	LEFT JOIN views v ON v.stream_id = s.id
//	WHERE s.user_id = $1
//	GROUP BY s.id
//	ORDER BY s.id DESC
func (q *Queries) GetUserStreams(ctx context.Context, userID int32) ([]GetUserStreamsRow, error) {
	rows, err := q.db.Query(ctx, getUserStreams, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserStreamsRow
	for rows.Next() {
		var i GetUserStreamsRow
		if err := rows.Scan(
			&i.Name,
			&i.Key,
			&i.IsActive,
			&i.EndedAt,
			&i.StartedAt,
			&i.TotalViews,
			&i.IsVod,
			&i.LiveViewers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllStreams = `-- name: RemoveAllStreams :exec
TRUNCATE streams CASCADE
`

// RemoveAllStreams
//
//	TRUNCATE streams CASCADE
func (q *Queries) RemoveAllStreams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, removeAllStreams)
	return err
}

const removeStream = `-- name: RemoveStream :exec
DELETE FROM streams 
WHERE id = $1
`

// RemoveStream
//
//	DELETE FROM streams
//	WHERE id = $1
func (q *Queries) RemoveStream(ctx context.Context, streamID int32) error {
	_, err := q.db.Exec(ctx, removeStream, streamID)
	return err
}

const startStream = `-- name: StartStream :one
SELECT start_stream($1)
AS started
`

// StartStream
//
//	SELECT start_stream($1)
//	AS started
func (q *Queries) StartStream(ctx context.Context, streamKey string) (bool, error) {
	row := q.db.QueryRow(ctx, startStream, streamKey)
	var started bool
	err := row.Scan(&started)
	return started, err
}

const stopStream = `-- name: StopStream :exec
UPDATE streams 
SET 
  is_active = FALSE, 
  ended_at = NOW() 
WHERE id = $1
`

// StopStream
//
//	UPDATE streams
//	SET
//	  is_active = FALSE,
//	  ended_at = NOW()
//	WHERE id = $1
func (q *Queries) StopStream(ctx context.Context, streamID int32) error {
	_, err := q.db.Exec(ctx, stopStream, streamID)
	return err
}
